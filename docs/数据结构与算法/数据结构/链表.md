## 一、什么是链表？
- 1.和数组一样，链表也是一种线性表。
- 2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
- 3.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。

## 二、为什么使用链表？即链表的特点
- 1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
- 2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

## 三、常用链表：单链表、循环链表和双向链表
### 1.单链表
- 1）每个节点只包含一个指针，即后继指针。
- 2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。
- 3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。
### 2.循环链表
- 1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。
- 2）适用于存储有循环特点的数据，比如约瑟夫问题。

### 3.双向链表
- 1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。
- 2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。
- 3）性能特点：<br/>
和单链表相比，存储相同的数据，需要消耗更多的存储空间。<br/>
插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为两种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O
(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br/>
对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

### 4.双向循环链表
首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。

## 四、选择数组还是链表？

1. 插入、删除和随机访问的时间复杂度<br/>
数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br/>
链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。<br/>

2. 数组缺点<br/>
1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br/>
2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<br/>

3. 链表缺点<br/>
1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br/>
2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。

4. 如何选择？<br/>
数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。如果代码对内存的使用非常苛刻，那数组就更适合。

## 五、如何写好链表代码？
### 1. 理解指针或引用的含义
什么是指针？指针是一个变量，该变量中存的是其它变量的地址。将普通变量赋值给指针变量，其实是把它的地址赋值给指针变量。

### 2. 警惕指针丢失和内存泄漏
在插入和删除结点时，要注意先持有后面的结点再操作，否者一旦后面结点的前继指针被断开，就无法再访问，导致内存泄漏。

### 3. 利用哨兵简化难度
链表的插入、删除操作，需要对插入第一个结点和删除最后一个节点做特殊处理。利用哨兵对象可以不用边界判断，链表的哨兵对象是只存指针不存数据的头结点。

### 4. 重点留意边界条件处理
操作链表时要考虑链表为空、一个结点、两个结点、头结点、尾结点的情况。学习数据结构和算法主要是掌握一系列思想，能在其它的编码中也养成考虑边界的习惯。

### 5. 举例画图，辅助思考
对于比较复杂的操作，可以用纸笔画一画，释放脑容量来做逻辑处理（时间换空间思想），也便于完成后的检查。

### 6. 多写多练，没有捷径
孰能生巧，不管是什么算法，只有经过反复的练习，才能信手拈来。