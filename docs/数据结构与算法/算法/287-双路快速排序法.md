1、算法出现的背景

之前讲的，当我们排序的是一个近乎有序的序列时，快速排序会退化到一个O\(n^2\)级别的排序算法，

而对此的改进就是引入了随机化快速排序算法；但是当我们排序的是一个数值重复率非常高的序列时，

此时随机化快速排序算法就不再起作用了，而将会再次退化为一个O\(n^2\)级别的排序算法，那为什么

会出现这种情况呢？且听下面的分析:



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170309233926688-2074293025.png)

如上图所示就是之前分析的快速排序算法的partition的操作原理，我们通过判断此时i索引指向的数组

元素e&gt;v还是&lt;v，将他放在橙色或者是紫色两个不同的位置，然后将整个数组分成两个部分递归下去；

但是这里其实我们是没有考虑=v的情况，其实隐含的意思就是下面的两种情况:



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170309235814594-813692747.png)![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170309235825281-246477239.png)

其实从这里就可以看出来了，不管是&gt;=v还是&lt;=v，当我们的序列中存在大量重复的元素时，

排序完成之后就会将整个数组序列分成两个极度不平衡的部分，所以又退化到了O\(n^2\)级别

的时间复杂度，这是因为对于每一个"基准"元素来说，重复的元素太多了，如果我们选的"基准"

元素稍微有一点的不平衡，那么就会导致两部分的差距非常大；即时我们的"基准"元素选在了

一个平衡的位置，但是由于等于"基准"元素的元素也非常多，也会使得序列被分成两个及其不平

衡的部分，那么在这种情况下快速排序就又会退化成O\(n^2\)级别的排序算法。如何解决呢？

这就要用到今天讲的双路快速排序算法的原理了。



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170310000613000-29903960.png)



2、双路快速排序算法的原理

之前说的快速排序算法是将&gt;v和&lt;v两个部分元素都放在索引值i所指向的位置的左边部分，而我们

的双路快速排序算法则不同，他使用两个索引值（i、j）用来遍历我们的序列，将&lt;v的元素放在索

引i所指向位置的左边，而将&gt;v的元素放在索引j所指向位置的右边，这也正是双路排序算法的

partition原理:



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170310130917029-1431607711.png)

基本思想: 

![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170310131600576-340084183.png) 

首先从左边的i索引往右边遍历，如果i指向的元素&lt;v，那直接将i++移动到下一个位置，直道i指向的元素&gt;=v则停止



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170310131850217-16046036.png) 

然后使用j索引从右边开始往左边遍历，如果j指向的元素&gt;v，那直接将j--移动到下一个位置，直道j指向的元素&lt;=v则停止



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170310132107529-1940126323.png) 

此时i之前的元素都已经归并为&lt;v的部分了，而j之后的元素也都已经归并为&gt;v的部分了，此时只需要将arr\[i\]和arr\[j\]交换位置即可



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170310210733045-1597747186.png) 

这样就可以避免出现=v的元素全部集中在某一个部分，这正是双路排序算法的一个核心



![](https://images2015.cnblogs.com/blog/944893/201703/944893-20170310210941748-1373423530.png)  

将i++，j--开始遍历后后面的元素



