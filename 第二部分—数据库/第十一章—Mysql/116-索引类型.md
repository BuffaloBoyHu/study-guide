1. 普通索引  
普通索引\(由关键字KEY或INDEX定义的索引\)的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件\(WHERE column = …\)或排序条件\(ORDER BY column\)中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列\(如一个整数类型的数据列\)来创建索引。

  
2. 唯一索引  
普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个”员工个人资料”数据表里可能出现两次或更多次。  
如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简 化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在 某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯 一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。

  
3. 主键索引  
在前面已经反复多次强调过：必须为主键字段创建一个索引，这个索引就是所谓的”主索引”。主索引与唯一索引的唯一区别是：前者在定义时使用的关键字是 PRIMARY而不是UNIQUE。

  
4. 外键索引  
如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。

  
5. 复合索引  
索引可以覆盖多个数据列，如像INDEX\(columnA, columnB\)索引。这种索引的特点是MySQL可以有选择地使用一个这样的索引。如果查询操作只需要用到columnA数据列上的一个索引，就可以使 用复合索引INDEX\(columnA, columnB\)。不过，这种用法仅适用于在复合索引中排列在前的数据列组合。比如说，INDEX\(A, B, C\)可以当做A或\(A, B\)的索引来使用，但不能当做B、C或\(B, C\)的索引来使用。  
6. 索引的长度  
在为CHAR和VARCHAR类型的数据列定义索引时，可以把索引的长度限制为一个给定的字符个数\(这个数字必须小于这个字段所允许的最大字符个数\)。这 么做的好处是可以生成一个尺寸比较小、检索速度却比较快的索引文件。在绝大多数应用里，数据库中的字符串数据大都以各种各样的名字为主，把索引的长度设置 为10~15个字符已经足以把搜索范围缩小到很少的几条数据记录了。  
在为BLOB和TEXT类型的数据列创建索引时，必须对索引的长度做出限制；MySQL所允许的最大索引长度是255个字符。

全文索引  
文本字段上的普通索引只能加快对出现在字段内容最前面的字符串\(也就是字段内容开头的字符\)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成 的较大段文字，普通索引就没什么作用了。这种检索往往以LIKE %word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。  
这类场合正是全文索引\(full-text index\)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数 据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加：  
ALTER TABLE tablename ADD FULLTEXT\(column1, column2\)  
有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。下面是这类查询命令的基本语法：  
SELECT \* FROM tablename  
WHERE MATCH\(column1, column2\) AGAINST\(‘word1′, ‘word2′, ‘word3′\)  
上面这条命令将把column1和column2字段里有word1、word2和word3的数据记录全部查询出来。  
注解：InnoDB数据表不支持全文索引。



